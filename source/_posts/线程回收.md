---
title: 线程回收
categories: [linux应用编程,线程]
---

--------------

## 线程回收函数

线程和进程一样，子线程退出的时候其内核资源主要由主线程回收（也可由其他线程回收），线程库中提供的线程回收函数叫做pthread_join()，这是一个阻塞函数，如果还有子线程在运行，主线程调用该函数就会阻塞，并且等待子线程运行退出，退出后主线程解除阻塞状态并进行资源回收，函数被调用一次只能回收一个子线程，有多个子线程需要多次调用；另外通过线程回收函数还可以获取到子线程退出时传递出来的数据；

线程回收函数原型：

~~~c
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
~~~

- 参数
  - thread：回收的线程ID
  - retval：二级指针，用来存储pthread_exit ()传递出来的数据的地址，不需要获取数据可以指定为NULL
- 返回值
  - 回收成功返回0，失败返回错误号

## 线程回收示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

typedef struct data
{
    char name[10];
    int age;
}data;

void *callback(void *arg)
{
    printf("我是子线程，线程ID：%lu\r\n",pthread_self());
    int i = 0;
    while(i<5)
    {
        i++;
        printf("子线程运行中，i = %d\r\n",i);
        data my;
        strcpy(my.name, "thui");
        my.age = 22;
        pthread_exit(&my);
    }
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, NULL, callback, NULL);
    printf("子线程创建成功，线程ID：%lu\r\n", tid);
    printf("我是主线程，线程ID：%lu\r\n", pthread_self());
    //使用这个指针接收子线程回收后传出的数据
    void *p = NULL;
    pthread_join(tid, &p);
    data *child_data = (data *)p;
    printf("child name：%s age：%d\r\n",child_data->name,child_data->age);
    printf("子线程资源被成功回收\r\n");
    return 0;
}
~~~

## 编译并执行测试程序

~~~shell
子线程创建成功，线程ID：140166532716096
我是主线程，线程ID：140166532720448
我是子线程，线程ID：140166532716096
子线程运行中，i = 1
child name：age：32635
子线程资源被成功回收
~~~

打印出来后发现信息并不是我们想要传递的信息，这是因为子线程在被回收后，子线程的栈空间就被回收，此时指向该空间得到的数据是一个随机值，显然，我们需要把想要传递出的数据放到堆或者全局段，或者让子线程使用主线程的栈空间；

## 使用主线程栈空间示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

typedef struct data
{
    char name[10];
    int age;
}data;

void* callback(void *arg)
{
    printf("我是子线程，线程ID：%lu\r\n",pthread_self());
    int i = 0;
    while(i<5)
    {
        i++;
        printf("子线程运行中，i = %d\r\n",i);
        data *my = (data *)arg;
        strcpy(my->name, "thui");
        my->age = 22;
        pthread_exit(&my);
    }
}

int main()
{
    pthread_t tid;
    data child_data;
    pthread_create(&tid, NULL, callback, &child_data);
    printf("子线程创建成功，线程ID：%lu\r\n", tid);
    printf("我是主线程，线程ID：%lu\r\n", pthread_self());
    //使用这个指针接收子线程回收后传出的数据
    void *p = NULL;
    pthread_join(tid, &p);
    printf("child name：%s age：%d\r\n",child_data.name,child_data.age);
    printf("子线程资源被成功回收\r\n");
    return 0;
}
~~~

## 编译并执行测试程序

~~~shell
子线程创建成功，线程ID：139701678691904
我是主线程，线程ID：139701678696256
我是子线程，线程ID：139701678691904
子线程运行中，i = 1
child name：thui age：22
子线程资源被成功回收
~~~

