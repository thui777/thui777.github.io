---
title: 线程退出
categories: [linux,线程进程]
---

----------

## 线程退出函数

在创建进程时，进程一般写为死循环，那么在创建子线程之后，子线程和主线程会进行抢占，当我们不需要某个线程时我们可以调用线程退出函数来退出线程，子线程和主线程都可以调用这个函数；

线程退出函数原型：

~~~c
#include <pthread.h>
void pthread_exit(void *retval);
~~~

- 参数
  - retval：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL

## 线程退出示例

~~~c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void *callback(void *arg)
{
    printf("我是子线程，线程ID：%lu\r\n",pthread_self());
    int i = 0;
    while(i<5)
    {
        i++;
        printf("子线程运行中，i = %d\r\n",i);
    }
    //进程从这里退出
    return NULL;
}

int main()
{
    pthread_t tid;
    //创建子线程，子线程处理函数为callback，传递参数为NULL，属性为NULL
    pthread_create(&tid, NULL, callback, NULL);
    printf("子线程创建成功，线程ID：%lu\r\n", tid);
    printf("我是主线程，线程ID：%lu\r\n", pthread_self());
    //退出主线程，但是地址空间不会被回收
    int i = 0;
    while(i<5)
    {
        i++;
        printf("主线程运行中，i = %d\r\n",i);
        pthread_exit(NULL);
    }
    //主线程退出后下面的语句并不会执行
    //主线程阻塞100秒，但是主线程退出了，观察不到进程阻塞状态
    sleep(100);
    return 0;
}
~~~

## 编译并执行测试程序

~~~shell
子线程创建成功，线程ID：139889038530112
我是主线程，线程ID：139889038534464
主线程运行中，i = 1
我是子线程，线程ID：139889038530112
子线程运行中，i = 1
子线程运行中，i = 2
子线程运行中，i = 3
子线程运行中，i = 4
子线程运行中，i = 5
~~~

主线程在执行第一次的时候就会退出，但是进程地址空间并不会被回收，在等待子线程执行完毕后，操作系统才会把进程的资源进行回收；
