---
title: 条件变量
categories: [linux,线程]
---

----

## 条件变量的作用

条件变量的主要作用使用来进行线程的阻塞；虽然锁也可以阻塞线程，但是它比较死板，不灵活，此时我们可以使用条件变量来阻塞线程，二者产生的效果是不同的；条件变量是，在满足特定条件后（一般根据场景自己定义）才会阻塞线程，如何条件不满足，多个线程还是会同时访问临界资源，单独使用时还是会造成共享数据的混乱，所以一般使用条件变量配合锁一起使用，即灵活又保证了共享数据的正确性；

在linux中定义一个条件变量：

~~~c
pthread_cond_t cond;
~~~

## 条件变量操作函数

#### 1.条件变量初始化函数

~~~c
int pthread_cond_init(pthread_cond_t *restrict cond,
                      const pthread_condattr_t *restrict attr);
~~~

-   参数
    -   cond：条件变量的地址
    -   attr：条件变量属性，默认为NULL
-   返回值
    -   初始化成功返回0，失败返回错误号

#### 2.释放条件变量函数

~~~c
int pthread_cond_destroy(pthread_cond_t *cond);
~~~

-   参数
    -   cond：条件变量的地址
-   返回值
    -   释放成功返回0，失败返回错误号

#### 3.条件变量阻塞函数

~~~c
int pthread_cond_wait(pthread_cond_t *restrict cond
                      pthread_mutex_t *restrict mutex);
~~~

-   参数
    -   cond：条件变量地址
    -   mutex：互斥锁变量地址
-   返回值
    -   阻塞成功返回0，失败返回错误号

在该函数阻塞线程时，需要一个互斥锁参数，这个互斥锁的功能主要是进行线程同步，让线程顺序进去临界区，避免出现共享资源数据混乱，该函数内部会操作这把锁，内部有几个细节：

-   在调用函数阻塞线程时，如果线程已经对互斥锁加锁，那么这个函数会把这把锁打开，以防止死锁的情况产生
-   当线程解除阻塞时，线程会竞争的给互斥锁加锁，加到锁的线程继续向下执行，没有加到锁的线程继续阻塞

#### 4.条件变量定时阻塞函数

~~~c
//表示的是从1970年1月1号到某个时间点的时间，总长度用秒或者纳秒表示
struct timespec
{
    time_t tv_sec;	//Second
    long tc_nsec;	//NaneSecond
};

//一般调用函数time()获取1970年1月1号到开始阻塞时的时间长度
struct timespec tmsp;
tmsp.tv_nsec = 0;
tmsp.tv_sec = time()+100;//阻塞100秒

int pthread_cond_timewait(pthread_cond_t *restrict cond,
                          pthread_mutex_t *restrict mutex,
                          const struct timespec *restrict abstime);
~~~

-   参数
    -   cond：条件变量地址
    -   mutex：互斥锁变量地址
    -   abstime：阻塞时长变量的地址，使用结构体表示
-   返回值
    -   阻塞成功返回0，失败返回错误号

调用这个函数会在条件阻塞中阻塞对应的时长，时长过后自动解除阻塞，不需要唤醒（我暂时不理解这个函数应该什么时候使用）

#### 5.线程唤醒函数

~~~c
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
~~~

-   参数
    -   cond：条件变量地址
-   返回值
    -   唤醒成功返回0，失败返回错误号

两个函数都可以唤醒被条件变量阻塞起来的线程，第一个函数是至少唤醒一个被阻塞的线程，第二个函数是唤醒所有被阻塞的线程

## 条件变量使用示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

//使用条件变量实现生产者和消费者模型，生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点

//创建互斥锁变量和条件变量
pthread_mutex_t mutex;
pthread_cond_t cond;

//声明结构体
struct Node
{
	int data;
	struct Node* next;
};

//初始化头节点
struct Node *head = NULL;

//生产者回调函数
void *producer(void *arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        struct Node *ptmp = (struct Node*)malloc(sizeof(struct Node));
        ptmp->data = rand()%1000;
        ptmp->next = head;
        head = ptmp;
        printf("id = %ld, producer data = %d\r\n",pthread_self(),ptmp->data);
        pthread_mutex_unlock(&mutex);
        //唤醒阻塞在条件变量的所有线程
        pthread_cond_broadcast(&cond);
        sleep(rand()%3);	
    }
}

//消费者回调函数
void *consumer(void *arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        /*
            必须使用while()循环，不可以使用if，因为在第一个线程加锁执行完毕解锁可能没问题，
            此时若生产者还未生产，第二个线程就已经加锁开始执行，那么此时是没有产品可以消耗的，
            但是if语句并不会再一次的进行条件判断，所以会产生bug，一般来说需要使用循环再次判
            断是否有产品，没有产品则继续调用条件变量阻塞函数阻塞线程
        */
        while(head == NULL)
        {
            /*
                当条件满足时调用这个函数阻塞线程
                阻塞时会解开互斥锁，防止死锁(生产者无法生产那么就永远会卡在这里)
                等待唤醒后，再次给互斥锁加锁，没加上锁的线程继续阻塞
            */
            pthread_cond_wait(&cond,&mutex);
        }
        struct Node * ctmp = head;
        printf("id = %ld, consumer data = %d\r\n",pthread_self(),ctmp->data);
        head = ctmp->next;
        free(ctmp);
        pthread_mutex_unlock(&mutex);
        sleep(rand()%3);
    }
}

int main()
{
    //初始化互斥锁和条件变量
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);
    //创建生产者线程和消费者线程
    pthread_t ptid[5], ctid[5];
    for(int i=0;i<5;i++)
    {
        pthread_create(&ptid[i],NULL,producer,NULL);
    }
    for(int i=0;i<5;i++)
    {
        pthread_create(&ctid[i],NULL,consumer,NULL);
    }
    //生产者线程和消费者线程回收
    for(int i=0;i<5;i++)
    {
        pthread_join(ptid[i],NULL);
    }
    for(int i=0;i<5;i++)
    {
        pthread_join(ctid[i],NULL);
    }
    //销毁互斥锁和条件变量资源
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    return 0;
}
~~~

## 编译并执行测试程序

~~~shell
id = 140015787005504, producer data = 383
id = 140015778612800, producer data = 777
id = 140015770220096, producer data = 793
id = 140015761827392, producer data = 386
id = 140015753434688, consumer data = 386
id = 140015745041984, consumer data = 793
id = 140015736649280, consumer data = 777
id = 140015728256576, consumer data = 383
id = 140015795398208, producer data = 690
id = 140015719863872, consumer data = 690
id = 140015761827392, producer data = 926
id = 140015753434688, consumer data = 926
id = 140015761827392, producer data = 172
id = 140015753434688, consumer data = 172
id = 140015778612800, producer data = 368
id = 140015770220096, producer data = 429
id = 140015787005504, producer data = 530
id = 140015745041984, consumer data = 530
id = 140015761827392, producer data = 67
id = 140015728256576, consumer data = 67
~~~

看上去有点像个栈，先生产出来的先消耗，仓库没有了就阻塞消费线程，等待生产或者是仓库满了，阻塞生产线程，等待消费，这就是典型的消费者生产者问题
