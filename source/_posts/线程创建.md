---
title: 线程创建
categories: [linux,线程进程]
---

--------------

## 返回线程ID函数

每一个线程都有一个唯一的线程ID，ID类型为pthread_t，为无符号长整型，想要得到线程ID则可使用函数；

返回线程ID函数原型：

~~~c
pthread_t pthraed_self(void);
~~~

- 返回参数
  - pthread_t：线程ID

## 线程创建函数

在一个线程中调用线程创建函数，就可以得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个线程处理函数，否则该子线程无法正常工作；

创建线程函数原型：

~~~c
#include <pthread.h>
int pthread_create(pthread_t *thread,
                   const pthread_arr_t *arrt,
                   void *(*start_routine)(void *),
                   void *arg);
~~~

- 参数
  - thread：传出参数，无符号长整型，创建成功将子线程ID写入thread
  - arrt：线程属性，一般为空
  - start_routine：函数指针，指向子线程处理函数
  - arg：传递参数，作为实参传递到start_routine函数内部
- 返回值
  - 成功返回0，失败返回错误号

## 创建线程示例

~~~c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void *callback(void *arg)
{
    printf("我是子线程，线程ID：%lu\r\n",pthread_self());
    return NULL;
}

int main()
{
    pthread_t tid;
    //创建子线程，子线程处理函数为callback，传递参数为NULL，属性为NULL
    pthread_create(&tid, NULL, callback, NULL);
    printf("子线程创建成功，线程ID：%lu\r\n", tid);
    printf("我是主线程，线程ID：%lu\r\n", pthread_self());
    //主线程阻塞1秒
    sleep(1);
    return 0;
}
~~~

## 编译并执行测试程序

~~~shell
thui777@thui777-VirtualBox:~/work/linux$ ./main 
子线程创建成功，线程ID：140206938711616
我是主线程，线程ID：140206938715968
我是子线程，线程ID：140206938711616
~~~

可以发现是先执行的主线程，再执行的子线程，因为线程执行顺序并不是像一般的C程序，先执行子线程，然后子线程执行结束再回到主线程执行，而是在子线程创建成功之后，子线程就会抢占时间片，如果在子线程还没抢占成功之前主线程就已经执行结束，那么进程的虚拟地址空间就会被回收，子线程就再也不会执行；所以说进程是资源分配的最小单位，而线程是系统调度执行的最小单位；