---
title: 线程同步
categories: [linux应用编程,线程]
---

---------

## 线程同步概念

#### 1.临界资源（共享资源）

在程序中，有的资源保存在堆区或者全局区，像这样可以供不同线程访问的资源，我们叫做临界资源或者共享资源；

#### 2.多个线程访问相同的临界资源会出现什么问题？

在程序中有多个线程时，每个线程都可以对临界区的资源进行访问，在分时复用系统中，A线程在访问临界区资源的同时，如果它的时间片已经使用完，那么就会进行上下文切换，此时对这个临界资源的修改会暂时的保存在寄存器中，而不会写入到内存；当B线程也来访问这个临界资源时，B线程会直接从内存资源中进行读取，等到B线程处理完毕把数据写入内存后又切换回A线程时，A线程就会把没及时写入内存的数据写入进去，此时相当于B线程对这个临界资源的修改是无效的，这显然对程序来说不是一个好的结果，为了解决这个问题，我们就需要使用线程同步；

#### 3.什么是线程同步？

当A线程在访问一个临界资源时，如果他的时间片使用完了，那么它会把这个临界资源给锁起来，然后B线程来访问这个资源时，就会被阻塞，阻塞掉之后就会切换回A线程就会继续执行，等待A线程执行完毕，然后再切换到B线程时，B线程就可以正常访问临界资源；我们可以得出线程同步的概念，实际上就是让线程访问临界资源时一个一个的访问，一个线程访问完毕之后另一个线程才能开始访问，没访问完毕时就给它锁起来，以防止临界资源出现数据混乱的问题；

## 线程同步的方式

常用的线程同步方式有四种：互斥锁，读写锁，条件变量，信号量；找到临界资源之后，再找到和临界资源相关的上下文代码，这样就可以得到一个代码块，这个代码块可以称为临界区；确定临界区之后，就可以进行线程同步了，具体思路是：

- 在临界区的上面添加加锁函数，对临界区加锁
- 哪个线程调用这句代码，就会把这把锁锁上，其他的线程就只能阻塞在锁上
- 在临界区的下边添加解锁函数，对临界区解锁
- 线程在出临界区时就会把那把锁打开，其他抢到锁的线程就可以进入到临界区

通过锁机制能保证临界区代码最多只能同时有一个线程访问，这个就可以把并行访问变为串行访问了；

## 未使用线程同步的示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

#define MAX 10
int number = 0;

void *fun_A(void *arg)
{
    int i = 0;
    while(i<MAX)
    {
        int a = number;
        a++;
        //加延时是为了模拟时间片使用完成但还没有写入内存的情况
        usleep(5);
        number = a;
        printf("thread A，ID = %ld，number = %d\r\n",pthread_self(), number);
        i++;
    }
}

void *fun_B(void *arg)
{
    int i = 0;
    while(i<MAX)
    {
        int b = number;
        b++;
        usleep(10);
        number = b;
        printf("thread B，ID = %ld，number = %d\r\n",pthread_self(), number);
        i++;
    }
}

int main()
{
    pthread_t thread_A;
    pthread_t thread_B;
    pthread_create(&thread_A, NULL, fun_A, NULL);
    pthread_create(&thread_B, NULL, fun_B, NULL);
    printf("线程A创建成功，线程ID：%ld\r\n",thread_A);
    printf("线程B创建成功，线程ID：%ld\r\n",thread_B);
    printf("我是主线程，线程ID：%ld\r\n",pthread_self());
    //退出主线程
    pthread_exit(NULL);
}
~~~

## 编译并执行测试程序

~~~shell
线程A创建成功，线程ID：140696243705408
线程B创建成功，线程ID：140696235312704
我是主线程，线程ID：140696243709760
thread A，ID = 140696243705408，number = 1
thread B，ID = 140696235312704，number = 2
thread A，ID = 140696243705408，number = 3
thread B，ID = 140696235312704，number = 4
thread B，ID = 140696235312704，number = 6
thread A，ID = 140696243705408，number = 6
thread A，ID = 140696243705408，number = 7
thread B，ID = 140696235312704，number = 7
thread B，ID = 140696235312704，number = 9
thread A，ID = 140696243705408，number = 9
thread A，ID = 140696243705408，number = 10
thread B，ID = 140696235312704，number = 10
thread B，ID = 140696235312704，number = 12
thread A，ID = 140696243705408，number = 12
thread A，ID = 140696243705408，number = 13
thread B，ID = 140696235312704，number = 13
thread B，ID = 140696235312704，number = 15
thread A，ID = 140696243705408，number = 15
thread A，ID = 140696243705408，number = 16
thread B，ID = 140696235312704，number = 16
~~~

每一次的模拟结果都可能不同，这就代表了在不进行线程同步的情况下产生的结果是随机的，这会给程序带来致命的打击；
