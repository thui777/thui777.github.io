---
title: 线程池
categories: [linux,线程]
---

---

## 线程直接使用的缺点

我们使用线程的时候就去创建一个线程，实现非常简便，但是会出现一个问题，如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁的创建线程就会大大降低系统的效率，因为频繁的创建线程和销毁线程都需要时间，系统开销太大；

## 什么是线程池？

线程池是一种多线程处理形式，处理过程中将任务添加到队列中，然后在线程池中创建线程自动的去执行这些任务；线程池的线程都是后台线程，每个线程使用默认堆栈大小，以默认优先级运行，并处于多线程单元中；如果某个线程始终保持空闲，则线程池将插入另一个辅助线程来使所有处理器保持繁忙；如果线程池中所有线程都保持繁忙，且队列中还有挂起的任务，则线程池将在一段时间后创建另一个辅助线程来执行这些任务，但是辅助线程的数量永远不会超过线程池设置的最大线程数，超过了最大线程数就必须使任务在队列中排队，等其他的线程完成后再执行这些任务，这样的一个逻辑系统就叫做线程池；

## 线程池实现原理

线程池主要由三部分组成

- 任务队列
  - 主要将待处理的任务提交到任务队列中，然后在任务被执行后将其从任务队列中删除
  - 任务队列不是无限大的，我们在初始化时需要设置队列的容量

- 工作线程
  - 工作区由一定数量的工作线程，这些线程会从任务队列中读取任务并且执行
  - 如果任务队列为空，那么工作区的线程将会被阻塞（使用条件变量或者信号量）
- 管理者线程
  - 在线程池中只有一个管理者线程，它负责根据任务队列中的任务数量调整工作线程的数量
  - 当任务过多时，适当的创建一些新的工作线程
  - 任务过少时，适当的销毁一些工作线程

## 一个线程池对象的基本属性

~~~c
//任务结构体
typedef struct Task
{
    void (*function)(void *arg);
    void* arg;
}Task;

struct ThreadPool 
{
	//任务队列的属性
	Task* taskQ;            //任务队列（使用一个队列存放任务）
	int queueCapacity;      //队列容量
	int queueSize;          //队列大小
	int queueFront;         //队列头
	int queueRear;          //队列尾
    
	//工作区的属性
	pthread_t* threadIDs;   //工作的线程ID（使用一个队列用来存放）
	int minNum;             //最小线程数
	int maxNum;             //最大线程数
	int busyNum;            //忙的线程数
	int liveNum;            //存活的线程数
	int exitNum;            //需要杀死的线程数

	//管理区的属性
	pthread_t managerID;          //管理者线程ID
	pthread_cond_t notFull;       //任务队列是否满
	pthread_cond_t notEmpty;      //任务队列是否空
	pthread_mutex_t mutexBusy;    //锁busyNum变量（因为访问频繁可以单独上把锁）
	pthread_mutex_t mutexPool;    //锁整个线程池
	int shutdown;                 //是否需要销毁线程池，销毁为1，不销毁为0
};
~~~

## 线程池的基本API函数有

1. 创建线程池并初始化
2. 销毁线程池
3. 给线程池添加任务
4. 获取线程池中工作的线程个数
5. 获取线程池中存活的线程个数
6. 工作的线程任务函数
7. 管理者线程任务函数
8. 单个线程退出

## 1.创建线程池并初始化

~~~c
ThreadPool* threadPoolCreate(int min, int max, int queueCapacity)
{
    ThreadPool* pool = (ThreadPool*)malloc(sizeof(ThreadPool));
    do
	{
		if (pool == NULL)
		{
			printf("malloc threadpool fail\r\n");
			break;
		}
        
		//任务队列属性初始化
		pool->taskQ = (Task*)malloc(sizeof(Task) * queueCapacity);
		pool->queueCapacity = queueCapacity;
		pool->queueSize = 0;
		pool->queueFront = 0;
		pool->queueRear = 0;
        
		//工作区属性初始化
		pool->threadIDs = (pthread_t*)malloc(sizeof(pthread_t) * max);
		if (pool->threadIDs == NULL)
		{
			printf("malloc threadIDs fail\r\n");
			break;
		}
		memset(pool->threadIDs, 0, sizeof(pthread_t) * max);
		pool->minNum = min;
		pool->maxNum = max;
		pool->busyNum = 0;
		pool->liveNum = min;
		pool->exitNum = 0;
        
		//管理区属性初始化
		if (pthread_mutex_init(&pool->mutexPool, NULL) != 0 ||
			pthread_mutex_init(&pool->mutexBusy, NULL) != 0 ||
			pthread_cond_init(&pool->notFull, NULL) != 0 ||
			pthread_cond_init(&pool->notEmpty, NULL) != 0)
		{
			printf("mutex or cond init fail\r\n");
			break;
		}
		pool->shutdown = 0;
        
        /*
        	因为需要把pool作为参数传入回调函数maneger and worker
        	所以需要先把pool的参数先初始化好，最后进行线程创建
        	如果线程创建写在前面则会出现段错误
        */
        //创建管理者线程
        pthread_create(&pool->managerID, NULL, maneger, pool);
        //创建工作线程进行工作
        for (int i = 0; i < min; i++)
		{
			pthread_create(&pool->threadIDs[i], NULL, worker, pool);
		}
        
		return pool;
	} while (0);
	
	//资源释放
	if (pool && pool->threadIDs)	free(pool->threadIDs); 
	if (pool && pool->taskQ)	free(pool->taskQ);
	if (pool)	free(pool);
}
~~~

## 2.销毁线程池

~~~c
int threadPoolDestroy(ThreadPool* pool)
{
	if(pool == NULL)
	{
		return -1;
	}
	//关闭线程池
	pool->shutdown = 1;
	//阻塞回收管理者线程
	pthread_join(pool->managerID, NULL);
	//唤醒阻塞的消费线程,让其自动退出
	for (int i = 0; i < pool->liveNum; i++)
	{
		pthread_cond_signal(&pool->notEmpty);
	}
	//释放堆内存
	if (pool->taskQ)
	{
		free(pool->taskQ);
	}
	if (pool->threadIDs)
	{
		free(pool->threadIDs);
	}

	//释放锁和条件变量
	pthread_mutex_destroy(&pool->mutexPool);
	pthread_mutex_destroy(&pool->mutexBusy);
	pthread_cond_destroy(&pool->notEmpty);
	pthread_cond_destroy(&pool->notFull);

    //最后释放线程池内存
	free(pool);
	pool = NULL;

	return 0;
}
~~~

## 3.给线程池添加任务

~~~c
void threadPoolAdd(ThreadPool* pool, void (*func)(void*), void* arg)
{
	pthread_mutex_lock(&pool->mutexPool);
	while (pool->queueSize == pool->queueCapacity && pool->shutdown == 0)
	{
		//阻塞生产者线程
		pthread_cond_wait(&pool->notFull, &pool->mutexPool);
	}
	if (pool->shutdown == 1)
	{
		pthread_mutex_unlock(&pool->mutexPool);
		return;
	}

	//添加任务
	pool->taskQ[pool->queueRear].function = func;
	pool->taskQ[pool->queueRear].arg = arg;
	pool->queueRear = (pool->queueRear + 1) % pool->queueCapacity;
	pool->queueSize++;

	//已经生产了，唤醒阻塞的工作线程
	pthread_cond_signal(&pool->notEmpty);

	pthread_mutex_unlock(&pool->mutexPool);
}
~~~

## 4.获取线程池中工作的线程个数

~~~c
int pthreadPoolBusyNum(ThreadPool* pool)
{
	pthread_mutex_lock(&pool->mutexBusy);
	int busyNum = pool->busyNum;
	pthread_mutex_unlock(&pool->mutexBusy);
	return busyNum;
}
~~~

## 5.获取线程池中存活的线程个数

~~~c
int pthreadPoolLiveNum(ThreadPool* pool)
{
	pthread_mutex_lock(&pool->mutexPool);
	int liveNum = pool->liveNum;
	pthread_mutex_unlock(&pool->mutexPool);
	return liveNum;
}
~~~

## 6.工作的线程任务函数

~~~c
void* worker(void* arg)
{
	ThreadPool* pool = (ThreadPool*)arg;
	while (1)
	{
		pthread_mutex_lock(&pool->mutexPool);
		//当前任务队列是否为空
		while (pool->queueSize == 0 && pool->shutdown == 0)
		{
			//任务队列中没有任务可以执行，阻塞工作线程
			pthread_cond_wait(&pool->notEmpty, &pool->mutexPool);
			//判断是否需要销毁线程
			if (pool->exitNum != 0)
			{
				pool->exitNum--;
				if (pool->liveNum > pool->minNum)
				{
					pool->liveNum--;
					pthread_mutex_unlock(&pool->mutexPool);
					threadExit(pool);
				}
			}
		}
		//判断线程池是否被关闭了
		if (pool->shutdown == 1)
		{
			//关闭了就打开互斥锁并退出线程
			pthread_mutex_unlock(&pool->mutexPool);
			threadExit(pool);
		}

		//从任务队列中取出一个任务
		Task task;
		task.function = pool->taskQ[pool->queueFront].function;
		task.arg = pool->taskQ[pool->queueFront].arg;

		//移动头节点(以循环队列的方式)
		pool->queueFront = (pool->queueFront + 1) % pool->queueCapacity;
		pool->queueSize--;

		//已经消费了，可以唤醒生产者线程
		pthread_cond_signal(&pool->notFull);

		pthread_mutex_unlock(&pool->mutexPool);

		//忙碌线程+1
		printf("thread %ld start working...\r\n");
		pthread_mutex_lock(&pool->mutexBusy);
		pool->busyNum++;
		pthread_mutex_unlock(&pool->mutexBusy);
		
		//执行任务
		(*task.function)(task.arg);

		//忙碌线程-1
		printf("thread %ld end working...\r\n");
		pthread_mutex_lock(&pool->mutexBusy);
		pool->busyNum--;
		pthread_mutex_unlock(&pool->mutexBusy);
	}
	return NULL;
}
~~~

## 7.管理者线程任务函数

~~~c
void* manager(void* arg)
{
	ThreadPool* pool = (ThreadPool*)arg;
	while (pool->shutdown == 0)
	{
		//每隔三秒钟检测一次
		sleep(3);
		
		//检测线程池中的任务数和当前线程数还有正在忙的线程数
		pthread_mutex_lock(&pool->mutexPool);
		int queueSize = pool->queueSize;
		int liveNum = pool->liveNum;
		int busyNum = pool->busyNum;
		pthread_mutex_unlock(&pool->mutexPool);

		//添加线程
		//任务的个数大于存活线程的个数  &&  存活的线程个数小于最大线程数
		if (queueSize > liveNum && liveNum < pool->maxNum)
		{
			//需要读取到pool中的共享资源，这一块临界区需要加锁
			pthread_mutex_lock(&pool->mutexPool);
			int counter = 0;
			//循环创建新的线程，每次创建个数为addNumer个，前提是存活的线程不能超过线程的最大个数
			for (int i = 0; i < pool->maxNum
				&& counter < NUMBER
				&& pool->liveNum < pool->maxNum; i++
				)
			{
				//i用来遍历到threadIDs的末尾，在线程队列的末尾添加新的线程
				if (pool->threadIDs[i] == 0)
				{
					pthread_create(&pool->threadIDs[i], NULL, worker, pool);
					counter++;
					pool->liveNum;
				}
			}
			pthread_mutex_unlock(&pool->mutexPool);
		}

		//销毁线程
		//任务的个数 *2 仍小于存活的线程个数，且存活线程个数大于最小线程个数
		if (busyNum * 2 < liveNum && liveNum > pool->minNum)
		{
			pthread_mutex_lock(&pool->mutexPool);
			pool->exitNum = NUMBER;
			pthread_mutex_unlock(&pool->mutexPool);
			//让阻塞的工作线程自杀
			for (int i = 0; i < NUMBER; i++)
			{
				//唤醒由notEmpty阻塞的线程
				pthread_cond_signal(&pool->notEmpty);
			}
		}
	}
	return NULL;
}
~~~

## 8.单个线程退出

~~~c
void threadExit(ThreadPool* pool)
{
	pthread_t tid = pthread_self();
	for (int i = 0; i < pool->maxNum; i++)
	{
		if (pool->threadIDs[i] == tid)
		{
			pool->threadIDs[i] == 0;
			printf("threadExit() called, %ld exiting...\r\n",tid);
			break;
		}
	}
	pthread_exit(NULL);
}
~~~

