---
title: 信号量
categories: [linux,线程]
---

-------

## 信号量的作用

信号量主要用于多线程多任务同步，一个线程完成了某个动作就通过信号量告诉别的线程，别的线程再进行某些动作；信号量不一定是锁定某一个资源，是流程上的概念，比如A,B两个线程，B线程需要等待A线程完成某些任务后再进行自己的任务，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类的；信号量也是用来阻塞线程的，但是不能完全保证线程安全，如果需要保证线程安全需要配合和互斥锁一起使用，信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行

linux中定义一个信号量：

~~~c
#include <semaphore.h>
sem_t sem;
~~~

## 信号量操作函数

#### 1.信号量初始化函数

~~~c
int sem_init(sem_t *sem, 
             int pshared, 
             unsigned int value);
~~~

- 参数
  - sem：信号量变量地址
  - pshared：
    - 0：线程同步
    - 非0：进程同步
  - value：初始化当前信号量拥有的资源数（>=0），如果资源数为0，线程就会被阻塞

#### 2.信号量资源释放函数

~~~c
int sem_destroy(sem_t *sem);
~~~

- 参数
  - sem：信号量变量地址

#### 3.资源消耗函数

~~~c
int sem_wait(sem_t *sem);
~~~

- 参数
  - sem：信号量变量地址

当线程调用这个函数，并且sem中的资源数大于0时，线程会占用掉sem中的一个资源，总资源数-1，当sem中的资源数变为0时，下一个调用该函数的线程会因为得不到资源而阻塞起来

#### 4.尝试资源消耗函数

~~~c
int sem_trywait(sem_t *sem);
~~~

- 参数
  - sem：信号量变量地址

调用这个函数和上面一个函数类似，只是当没有资源时，线程不会被阻塞，而是直接返回错误号，因此可以在函数中添加判断分支，用于处理获取资源失败之后的情况

#### 5.定时阻塞函数

~~~c
int sem_timedwait(sem_t *sem, 
                  const struct timespec *abs_timeout);
~~~

- 参数
  - sem：信号量变量地址
  - abs_timeout：阻塞时长结构体变量的地址

该函数的参数 abs_timeout 和 pthread_cond_timedwait 的最后一个参数是一样的，调用这个函数也和上面函数类型，只是当没有资源时，线程会阻塞指定的时长，过后线程自动解除阻塞

#### 6.资源释放函数

~~~c
int sem_post(sem_t *sem);
~~~

- 参数
  - sem：信号量变量的地址

调用该函数会将sem中的资源数+1，如果有线程在调用资源消耗函数时因为没有资源而被阻塞了，那么这些线程将会被唤醒，解除阻塞，然后获取资源继续向下运行

#### 7.获取资源数函数

~~~c
int sem_getvalue(sem_t *sem,
                 int *sval);
~~~

- 参数
  - sem：信号量变量地址
  - sval：传出参数，将资源数写入该参数

通过这个函数可以查看sem中现在拥有的资源个数，通过第二个参数将数据传入上层空间，类似于返回值

## 信号量使用示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <semaphore.h>

//使用信号量实现生产者和消费者模型，生产者有5个，消费者也有5个，仓库总只有5个资源位置

struct node
{
    int data;
    struct node *next;
};

struct node *head = NULL;

sem_t psem;
sem_t csem;
pthread_mutex_t mutex;

void *producer(void *arg)
{
    while(1)
    {
        //生产者取走一个信号量资源
        sem_wait(&psem);
        //加锁
        pthread_mutex_lock(&mutex);
        //上面两行代码不可以互换，可能会造成死锁
        struct node *temp = (struct node *)malloc(sizeof(struct node));
        temp->data = rand()%1000;
        temp->next = head;
        head = temp;
        printf("produser tid = %ld, data = %d\r\n",pthread_self(), temp->data);
        //解锁
        pthread_mutex_unlock(&mutex);
        //给到消费者一个信号量资源
        sem_post(&csem);
        sleep(rand()%3);
    }
}

void *consumer(void *arg)
{
    while(1)
    {
        //消费者取走一个信号量资源，开始没有资源，线程在这里阻塞
        sem_wait(&csem);
        //加锁
        pthread_mutex_lock(&mutex);
        //上面两行代码不可以互换，可能会造成死锁
        struct node *temp = head;
        printf("consumer tid = %ld, data = %d\r\n",pthread_self(), temp->data);
        head = temp->next;
        free(temp);
        //解锁
        pthread_mutex_unlock(&mutex);
        //给到生产者一个信号量资源
        sem_post(&psem);
        sleep(rand()%3);
    }
}

int main()
{
    pthread_mutex_init(&mutex,NULL);
    sem_init(&psem, 0, 5);
    sem_init(&csem, 0, 0);
    pthread_t ptid[5],ctid[5];
    for(int i=0; i<5; i++)
    {
        pthread_create(&ptid[i],NULL,producer,NULL);
        pthread_create(&ctid[i],NULL,consumer,NULL);
    }
    for(int i=0; i<5; i++)
    {
        pthread_join(ptid[i],NULL);
        pthread_join(ctid[i],NULL);
    }
    pthread_mutex_destroy(&mutex);
    sem_destroy(&psem);
    sem_destroy(&csem);
    return 0;
}

~~~

## 编译并执行测试程序

~~~shell
produser tid = 140042414900800, data = 383
consumer tid = 140042423293504, data = 383
produser tid = 140042398115392, data = 915
consumer tid = 140042406508096, data = 915
produser tid = 140042381329984, data = 386
consumer tid = 140042423293504, data = 386
produser tid = 140042364544576, data = 421
consumer tid = 140042389722688, data = 421
produser tid = 140042431686208, data = 690
consumer tid = 140042372937280, data = 690
produser tid = 140042381329984, data = 926
consumer tid = 140042356151872, data = 926
produser tid = 140042381329984, data = 172
consumer tid = 140042423293504, data = 172
produser tid = 140042414900800, data = 368
consumer tid = 140042356151872, data = 368
~~~

