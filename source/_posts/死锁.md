---
title: 死锁
categories: [linux应用编程,线程]
---

-------------------------------

## 什么叫死锁？

就是在线程给一把锁加锁后，一直没有解锁，那么来访问这个共享资源的线程都被阻塞了，这种一直打不开的锁就叫死锁，显然这样会对我们的系统造成不可预知的后果；

## 造成死锁的场景

#### 1.加锁后没有解锁

~~~c
//场景1
void *callback(void *arg)
{
    int i = 0;
    while(i<5)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        ......;
        ......;
        //忘记解锁
    }
}

//场景2
void *callback(void *arg)
{
    int i = 0;
    while(i<5)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        ......;
        ......;
        //线程退出导致解锁函数没有执行
        pthread_exit();
        pthread_mutex_unlock(&mutex);
    }
}

//场景3
void *callback(void *arg)
{
    int i = 0;
    while(i<5)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        ......;
        ......;
        //函数退出导致解锁函数没有执行
        return NULL;
        pthread_mutex_unlock(&mutex);
    }
}
~~~

加锁后忘记解锁，那么下次即使是加锁的线程去访问锁时也会被阻塞起来，那么就这块共享资源就永远不能被访问，就类似于你去图书馆借了一本书，但是你没有把这本书还回去，然后你又去图书馆借这本书，管理员告诉你这本书还没被还回来，需要你等待，然后你也不知道这本书你没有还回来，你就一直在图书馆等待着；

#### 2.重复加锁

~~~c
//场景1
void *callback(void *arg)
{
    int i = 0;
    while(i<5)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        //重复加锁
        pthread_mutex_lock(&mutex);
        ......;
        ......;
        pthread_mutex_unlock(&mutex);
    }
}

//场景2
void *callback_A(void *arg)
{
    int i = 0;
    while(i<5)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        ......;
        ......;
        pthread_mutex_unlock(&mutex);
    }
}

void *callback_B(void *arg)
{
    int i = 0;
    while(i<5)
    {
        //加锁
        pthread_mutex_lock(&mutex);
        //在调用其他函数时，其他函数对同一个互斥锁进行了加锁操作
        callback_A();
        ......;
        ......;
        pthread_mutex_unlock(&mutex);
    }
}
~~~

#### 3.相互加锁

A线程给锁A加了一把锁，然后B线程给锁B加了一把锁，然后线程B在访问锁A时被阻塞起来，线程A在访问锁B时也被阻塞起来，那么此时锁A和锁B都不能被解锁，那么来访问锁A和锁B的线程都会被阻塞，且锁A和锁B永远不会被解锁；

## 避免死锁

-   在对共享资源访问完毕之后及时解锁，或者在访问锁时使用trylock函数
-   避免多次加锁，多检查
-   程序中有多把锁时，在对其他互斥锁做加锁操作之前先释放当前线程拥有的互斥锁
-   在程序中引入检测死锁的模块