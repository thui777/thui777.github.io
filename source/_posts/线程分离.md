---
title: 线程分离
categories: [linux,线程进程]
---

---------

## 线程分离函数

在线程回收时，我们提到过，调用线程回收函数会阻塞线程，但是有时候我们的主线程有自己的业务需要处理，并不想让他阻塞起来，同时我们又想关闭回收某个子线程，这个时候我们就可以调用线程分离函数，让操作系统或者其他进程来接管和回收其占用的内核资源，但是线程分离出去之后并不会直接回收线程，有可能还会运行，但是当主线程已经执行完毕后，进程空间被释放，那么分离出去的子线程也会被释放掉；

线程分离函数原型：

~~~c
#include <pthread.h>

int pthread_detach(pthread_t thread);
~~~

- 参数
  - thread：线程ID
- 返回值
  - 分离成功返回0，失败返回错误号

## 线程分离示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *callback(void *arg)
{
    printf("我是子线程，线程ID：%lu\r\n",pthread_self());
    int i = 0;
    while(i<5)
    {
        i++;
        printf("子线程运行中，i = %d\r\n",i);
    }
    return NULL;
}

int main()
{
    pthread_t tid;
    pthread_create(&tid, NULL, callback, NULL);
    printf("子线程创建成功，线程ID：%lu\r\n",tid);
    printf("我是主线程，线程ID：%lu\r\n",pthread_self());
    //子线程分离出主线程
    pthread_detach(tid);
	int i = 0;
    while(i<5)
    {
        i++;
        printf("主线程运行中，i = %d\r\n",i);
    }
    pthread_exit(NULL);
    return 0;
}
~~~

## 编译并执行测试程序

~~~shell
子线程创建成功，线程ID：140198145324608
我是主线程，线程ID：140198145328960
主线程运行中，i = 1
主线程运行中，i = 2
主线程运行中，i = 3
主线程运行中，i = 4
主线程运行中，i = 5
我是子线程，线程ID：140198145324608
子线程运行中，i = 1
子线程运行中，i = 2
子线程运行中，i = 3
子线程运行中，i = 4
子线程运行中，i = 5
~~~

可以发现线程分离后主线程并没有被阻塞起来，而是继续运行，主线程运行完成并退出，子线程抢占成功且运行，运行完成后操作系统直接回收其占用的资源；