---
title: 互斥锁
categories: [linux,线程进程]
---

----------------

## 互斥锁的原理

互斥锁是线程同步最常用的一种方式，通过互斥锁锁定一个代码块，被锁定的这个代码块，所有的线程只能顺序执行（不能并行处理），但是需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，但现在只能串行处理；

在linux中创建一把互斥锁：

~~~c
pthread_mutex_t mutex;
~~~

在创建的锁变量中保存了这把锁的状态信息，比如锁定还是打开的，如果是锁定状态，互斥锁就记录了给这个锁加锁的线程信息（线程ID）；一个互斥锁变量只能被一个线程锁定，被锁定之后其他的线程再对互斥锁加锁就会被阻塞，知道这把锁被解锁，被阻塞的线程才能被解除阻塞；一般来说，每一个共享资源对应一把互斥锁，锁的个数和线程的个数无关；

## 互斥锁操作函数

#### 1.互斥锁初始化

~~~c
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);
~~~

- 参数
  - mutex：互斥锁类型变量的地址
  - attr：互斥锁的属性，一般为默认属性NULL
- 返回值
  - 初始化成功返回0，失败返回错误号

#### 2.释放互斥锁资源

~~~c
int pthread_mutex_destroy(pthread_mutex_t *mutex);
~~~

- 参数
  - mutex：互斥锁类型变量的地址
- 返回值
  - 释放成功返回0，失败返回错误号

#### 3.加锁

~~~c
int pthread_mutex_lock(pthread_mutex_t *mutex)；
~~~

- 参数
  - mutex：互斥锁类型变量的地址
- 返回值
  - 加锁成功返回0，失败返回错误号

这个函数被线程调用之后，首先会判断互斥锁是否为锁定状态，如果没有锁定，则该线程加锁成功，锁中就会记录该线程的ID，反之加锁失败，该线程被阻塞在这把锁上，当锁被解锁之后，该线程才能解除锁定状态，然后阻塞在这把锁上的线程又通过竞争的方式对这把锁进行加锁，没有抢占到的线程继续阻塞；

#### 4.尝试加锁

~~~c
int pthread_mutex_trylock(pthread_mutex_t *mutex);
~~~

- 参数
  - mutex：互斥锁类型变量的地址
- 返回值
  - 尝试加锁成功返回0，失败返回错误号

这个函数被线程调用之后，也是首先判断互斥锁是否为锁定状态，没有锁定则线程加锁成功，锁中记录该线程ID，反之加锁失败，但线程并不会阻塞在这把锁上，而是直接返回错误号，在调用时如果判断为加锁错误可以让线程先去做别的事情，而不用一直停留在加锁阻塞中；

#### 5.解锁

~~~c
int pthread_mutex_unlock(pthread_mutex_t *mutex);
~~~

- 参数
  - mutex：互斥锁类型变量的地址
- 返回值
  - 解锁成功返回0，失败返回错误号

在加锁时，互斥锁变量记录了加锁线程的ID，在解锁时，互斥锁也会对比线程ID，只有对这把锁加锁的线程才能对这把锁进行解锁；

## 使用互斥锁示例

~~~c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

#define MAX 10
int number = 0;
//创建互斥锁变量，所有线程全局共享
pthread_mutex_t mutex;

void *fun_A(void *arg)
{
    int i = 0;
    while(i<MAX)
    {
        //使用互斥锁加锁
        pthread_mutex_lock(&mutex);
        int a = number;
        a++;
        usleep(5);
        number = a;
        //使用互斥锁解锁
        pthread_mutex_unlock(&mutex);
        printf("thread A，ID = %ld，number = %d\r\n",pthread_self(), number);
        i++;
    }
}

void *fun_B(void *arg)
{
    int i = 0;
    while(i<MAX)
    {
        //使用互斥锁加锁
        pthread_mutex_lock(&mutex);
        int b = number;
        b++;
        usleep(5);
        number = b;
        //使用互斥锁解锁
        pthread_mutex_unlock(&mutex);
        printf("thread B，ID = %ld，number = %d\r\n",pthread_self(), number);
        i++;
        //加延时是为了演示当解锁后被另一个线程抢占的情况，否则基本都是由解锁的线程自己抢占掉了
        usleep(10);
    }
}

int main()
{
    pthread_t thread_A;
    pthread_t thread_B;
    pthread_create(&thread_A, NULL, fun_A, NULL);
    pthread_create(&thread_B, NULL, fun_B, NULL);
    printf("线程A创建成功，线程ID：%ld\r\n",thread_A);
    printf("线程B创建成功，线程ID：%ld\r\n",thread_B);
    printf("我是主线程，线程ID：%ld\r\n",pthread_self());
    //退出主线程
    pthread_exit(NULL);
}
~~~

## 编译并执行测试程序

~~~shell
线程A创建成功，线程ID：139733996975680
线程B创建成功，线程ID：139733988582976
我是主线程，线程ID：139733996980032
thread B，ID = 139733988582976，number = 1
thread A，ID = 139733996975680，number = 2
thread A，ID = 139733996975680，number = 3
thread A，ID = 139733996975680，number = 4
thread A，ID = 139733996975680，number = 5
thread A，ID = 139733996975680，number = 6
thread A，ID = 139733996975680，number = 7
thread A，ID = 139733996975680，number = 8
thread A，ID = 139733996975680，number = 9
thread A，ID = 139733996975680，number = 10
thread A，ID = 139733996975680，number = 11
thread B，ID = 139733988582976，number = 12
thread B，ID = 139733988582976，number = 13
thread B，ID = 139733988582976，number = 14
thread B，ID = 139733988582976，number = 15
thread B，ID = 139733988582976，number = 16
thread B，ID = 139733988582976，number = 17
thread B，ID = 139733988582976，number = 18
thread B，ID = 139733988582976，number = 19
thread B，ID = 139733988582976，number = 20
~~~

